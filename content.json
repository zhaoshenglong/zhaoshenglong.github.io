{"pages":[],"posts":[{"title":"Deploy linux kernel on QEMU","text":"本文主要是记录我第一次使用 Qemu 运行 Linux kernel 的过程。整个过程包括下载、编译、制作根文件系统、编写 init 脚本几个步骤。由于是第一次使用 Qemu 运行 linux kernel，难免会有些问题，希望不要误导大家。 1. Introduction本文章主要是分享我在初次接触使用 Qemu 运行编译后的 linux kernel 的经验。由于是新手，文中难免有错误，敬请批评指正 2. 开发环境首先我们需要有一个宿主机，也就是用来运行 Qemu*，编译 *Linux 的主机。我在本文中主要是使用的 vmware 虚拟机，系统是 Ubuntu 18.04 LTS。 下载必须的开发工具，包括 Qemu，Linux kernel，gcc 等等 2.1 下载安装 Qemu在 Qemu 官网上下载 Qemu 源码，版本可以选择最新的 stable 版本，我在本次实验中选择的是 Qemu v4.2.1 下载好之后，需要编译安装。 这里可以直接按照 Qemu 官网上的安装教程做，命令也不复杂，只是由于使用的都是默认的配置，因此会将大部分的工具都编译安装，编译过程会比较慢。 12345wget https://download.qemu.org/qemu-4.2.1.tar.xztar xvJf qemu-5.1.0-rc1.tar.xzcd qemu-5.1.0-rc1./configuremake 编译完成后，默认是不会将工具安装到系统中的，所有的可执行文件都在下载解压后的目录中，运行虚拟机所需要的可执行文件也在该目录中，对应于 &lt;平台&gt;-softmmu 目录中，比如 x86_64 平台的虚拟机在 x86_64-softmmu 目录中，aarch64 平台的虚拟机在 aarch64-softmmu目录中。 为了方便直接引用目标平台的可执行虚拟机文件（以下都以x86-64为例），我们可以创建 qemu-system-x86_64 的软链接，将这个软链接文件放在 PATH 中。ln -s &lt;绝对路径&gt;/qemu-4.2.1/x86_64-softmmu/qemu-system-x86_64 /usr/bin/qemu-system-x86_64 2.2 下载 Linux kernel下载 Linux 内核 在 github 或者 kernel.org 上下载即可，推荐下载 LTS 的内核版本，可以在 kernel.org 2.3 利用 busybox 制作内存根文件系统","link":"/2020/07/21/Deploy-linux-kernel-on-QEMU/"},{"title":"test-comment","text":"This is this is a test","link":"/2020/12/04/test-comment/"},{"title":"Flexible System Call Scheduling with Exception-Less System Calls","text":"1. 摘要本篇论文主要介绍的一种新型 系统调用 思路。 传统系统调用主要是通过内核提供入口，用户态调用时通过特殊的机器指令和相应的寄存器进入内核执行相关的函数调用。而本篇论文提出的新型系统调用主要是一种依赖于共享内存、后台内核线程技术的函数调用，这种函数调用不需要用户态陷入内核，而这样子做的好处主要是能够提高用户态代码的locality 本篇论文的首先会评测分析传统系统调用在 system intensive workloads 下对性能的严重影响；在基于这种现象的观察基础上，作者提出了新型系统调用，并对其设计实现进行了阐述；最后作者在 Apache、MySQL上应用了新型系统调用，来评测分析这种修改对性能的提升效果。 2. 设计实现2.1 传统系统调用及性能问题传统系统调用是用户态用来和 kernel 通信的主要方式，依赖于同步的调用模型，在系统调用完成之前，应用程序无法进行用户态的执行。 传统系统调用的问题主要是，在一些系统调用密集的工作负载下，从用户态切换刀内核态执行，将会破坏应用态的 locality，对 locality 的破坏将会严重的影响应用程序的性能。 2.2 exception-less system call显然，传统系统调用的问题主要就是对 locality 的破坏，导致硬件的利用率差，而 locality 的破坏主要是由于用户态和内核态的切换导致的，即主要是由于 exception-based execution mode l造成的。 本文提出了一种 exception-less system call。用户态和内核态之间共享一个 syscall page，用户态将系统调用的请求写入这个共享内存，内核态的特殊线程（syscall threads）负责处理这个共享内存的所有请求。 2.2.1 设计exception-less system call 的设计包含两方面 提供给用户态线程一个注册 system calls 的接口 提供一个异步的内核态线程系统，负责处理 system calls 2.2.1.1 用户态接口 syscall page syscall page 是内核态和用户态之间共享的内存，主要用来存放 系统调用 entry。用户态应用程序在需要系统调用时，需要在这段内存中寻找一个空闲的 entry，然后填入相应的字段。 syscall entry 包含的字段主要有：syscall number、arguments、status [free / submitted / busy / done]、result syscall number number of arguments status arg1 … arg6 return value 4Byte 2Byte 2Byte 8Byte … 8Byte 8Byte 2.2.1.2 内核态异步执行线程exception-less system call 不会主动通知内核有系统调用请求，因此内核态需要一种机制来异步处理这种请求，这种在内核态下专门处理系统调用请求的线程被称作 syscall thread。 syscall threads 只有在用户态线程无法继续执行的时候才会被唤醒，然后执行请求。 syscall threads 可以被调度在和用户态线程不同的 core 上，以此来提高用户态线程的 locality。 2.2.2 实现在 exception-less syscall 的实现中还需要2个使用 传统系统调用 方式的系统调用接口：flex_register 和 flex_wait，这两个系统调用接口主要是作为扩展，用来启用 FlexSC（即本文实现的exception-less syscall） 的接口 2.2.2.1 flex_registerflex_register 主要是用户态用来启用 FlexSC 的接口，当用户态的进程需要使用 FlexSC 时，应当在 process 创建时，调用这个系统调用。 flex_register 的执行逻辑主要包含2部分 在内核态映射 syscall pages 到用户态 为每一个syscall entry创建一个syscall threads 2.2.2.2 flex_waitflex_wait 也是一个传统系统调用，用来在用户态线程无法继续执行的情况下，主动通知内核唤醒 syscall threads 处理系统调用请求。当有至少一个 syscall 完成，就可以唤醒用户态由于无法继续执行而进入等待的线程。","link":"/2020/07/08/Paper-Reading-FlexSC-Flexible-System-Call-Scheduling-with-Exception-Less-System-Calls/"}],"tags":[{"name":"Linux kernel","slug":"Linux-kernel","link":"/tags/Linux-kernel/"},{"name":"Qemu","slug":"Qemu","link":"/tags/Qemu/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"syscall","slug":"syscall","link":"/tags/syscall/"},{"name":"linux","slug":"linux","link":"/tags/linux/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Note","slug":"Linux/Note","link":"/categories/Linux/Note/"},{"name":"Paper Reading","slug":"Paper-Reading","link":"/categories/Paper-Reading/"}]}