{"pages":[],"posts":[{"title":"Deploy linux kernel on QEMU","text":"本文主要是记录我第一次使用 Qemu 运行 Linux kernel 的过程。整个过程包括下载、编译、制作根文件系统、编写 init 脚本几个步骤。由于是第一次使用 Qemu 运行 linux kernel，难免会有些问题，希望不要误导大家。 1. Introduction本文章主要是分享我在初次接触使用 Qemu 运行编译后的 linux kernel 的经验。由于是新手，文中难免有错误，敬请批评指正 2. 开发环境首先我们需要有一个宿主机，也就是用来运行 Qemu*，编译 *Linux 的主机。我在本文中主要是使用的 vmware 虚拟机，系统是 Ubuntu 18.04 LTS。 下载必须的开发工具，包括 Qemu，Linux kernel，gcc 等等 2.1 下载安装 Qemu在 Qemu 官网上下载 Qemu 源码，版本可以选择最新的 stable 版本，我在本次实验中选择的是 Qemu v4.2.1 下载好之后，需要编译安装。 这里可以直接按照 Qemu 官网上的安装教程做，命令也不复杂，只是由于使用的都是默认的配置，因此会将大部分的工具都编译安装，编译过程会比较慢。 12345wget https://download.qemu.org/qemu-4.2.1.tar.xztar xvJf qemu-5.1.0-rc1.tar.xzcd qemu-5.1.0-rc1./configuremake 编译完成后，默认是不会将工具安装到系统中的，所有的可执行文件都在下载解压后的目录中，运行虚拟机所需要的可执行文件也在该目录中，对应于 &lt;平台&gt;-softmmu 目录中，比如 x86_64 平台的虚拟机在 x86_64-softmmu 目录中，aarch64 平台的虚拟机在 aarch64-softmmu目录中。 为了方便直接引用目标平台的可执行虚拟机文件（以下都以x86-64为例），我们可以创建 qemu-system-x86_64 的软链接，将这个软链接文件放在 PATH 中。ln -s &lt;绝对路径&gt;/qemu-4.2.1/x86_64-softmmu/qemu-system-x86_64 /usr/bin/qemu-system-x86_64 2.2 下载 Linux kernel下载 Linux 内核 在 github 或者 kernel.org 上下载即可，推荐下载 LTS 的内核版本，可以在 kernel.org 2.3 利用 busybox 制作内存根文件系统","link":"/2020/07/21/Deploy-linux-kernel-on-QEMU/"},{"title":"Flexible System Call Scheduling with Exception-Less System Calls","text":"1. 摘要本篇论文主要介绍的一种新型 系统调用 思路。 传统系统调用主要是通过内核提供入口，用户态调用时通过特殊的机器指令和相应的寄存器进入内核执行相关的函数调用。而本篇论文提出的新型系统调用主要是一种依赖于共享内存、后台内核线程技术的函数调用，这种函数调用不需要用户态陷入内核，而这样子做的好处主要是能够提高用户态代码的locality 本篇论文的首先会评测分析传统系统调用在 system intensive workloads 下对性能的严重影响；在基于这种现象的观察基础上，作者提出了新型系统调用，并对其设计实现进行了阐述；最后作者在 Apache、MySQL上应用了新型系统调用，来评测分析这种修改对性能的提升效果。 2. 设计实现2.1 传统系统调用及性能问题传统系统调用是用户态用来和 kernel 通信的主要方式，依赖于同步的调用模型，在系统调用完成之前，应用程序无法进行用户态的执行。 传统系统调用的问题主要是，在一些系统调用密集的工作负载下，从用户态切换刀内核态执行，将会破坏应用态的 locality，对 locality 的破坏将会严重的影响应用程序的性能。 2.2 exception-less system call显然，传统系统调用的问题主要就是对 locality 的破坏，导致硬件的利用率差，而 locality 的破坏主要是由于用户态和内核态的切换导致的，即主要是由于 exception-based execution mode l造成的。 本文提出了一种 exception-less system call。用户态和内核态之间共享一个 syscall page，用户态将系统调用的请求写入这个共享内存，内核态的特殊线程（syscall threads）负责处理这个共享内存的所有请求。 2.2.1 设计exception-less system call 的设计包含两方面 提供给用户态线程一个注册 system calls 的接口 提供一个异步的内核态线程系统，负责处理 system calls 2.2.1.1 用户态接口 syscall page syscall page 是内核态和用户态之间共享的内存，主要用来存放 系统调用 entry。用户态应用程序在需要系统调用时，需要在这段内存中寻找一个空闲的 entry，然后填入相应的字段。 syscall entry 包含的字段主要有：syscall number、arguments、status [free / submitted / busy / done]、result syscall number number of arguments status arg1 … arg6 return value 4Byte 2Byte 2Byte 8Byte … 8Byte 8Byte 2.2.1.2 内核态异步执行线程exception-less system call 不会主动通知内核有系统调用请求，因此内核态需要一种机制来异步处理这种请求，这种在内核态下专门处理系统调用请求的线程被称作 syscall thread。 syscall threads 只有在用户态线程无法继续执行的时候才会被唤醒，然后执行请求。 syscall threads 可以被调度在和用户态线程不同的 core 上，以此来提高用户态线程的 locality。 2.2.2 实现在 exception-less syscall 的实现中还需要2个使用 传统系统调用 方式的系统调用接口：flex_register 和 flex_wait，这两个系统调用接口主要是作为扩展，用来启用 FlexSC（即本文实现的exception-less syscall） 的接口 2.2.2.1 flex_registerflex_register 主要是用户态用来启用 FlexSC 的接口，当用户态的进程需要使用 FlexSC 时，应当在 process 创建时，调用这个系统调用。 flex_register 的执行逻辑主要包含2部分 在内核态映射 syscall pages 到用户态 为每一个syscall entry创建一个syscall threads 2.2.2.2 flex_waitflex_wait 也是一个传统系统调用，用来在用户态线程无法继续执行的情况下，主动通知内核唤醒 syscall threads 处理系统调用请求。当有至少一个 syscall 完成，就可以唤醒用户态由于无法继续执行而进入等待的线程。","link":"/2020/07/08/Paper-Reading-FlexSC-Flexible-System-Call-Scheduling-with-Exception-Less-System-Calls/"},{"title":"日记:记一个不是很开心的周六","text":"上午参加了学校组织的 129冬季长跑 ，和协会里的战友一起跑了十公里。 跑之前，大家都说配速5-6分钟，结果跑起来配速4′40。 我第一个五公里感觉还能跟上，结果第二个五公里刚开始就系鞋带，然后就掉队了，最后只能看着他们一起冲线，而我却只能一个人默默的过线。 配速不是特别快，但是对于我甲亢一年多没运动的人来说，这是这几年来第二个十公里，还是有点难度。第一个十公里是一个星期前的练习，当时跑了52分钟，配速大概5’11″。 但是让我难过的并不是我没有跟上队伍的步伐，真正让我难过的是，我在第二个五公里自己的意志力不够坚强，满脑子都是想休息，然后出列系鞋带，最后就没有再追上队伍。可笑的是，刚开始跑的时候，我还说了一句，“谁要是掉队了，就说一句，大家一起拖你”。最后就我一个人掉队了，哈哈哈 :cry: 跑完后和好朋友一起拍了照，每次拍照还是笑得傻傻的，哈哈哈。 右边的是我 让我比较佩服的是有一个退伍很久的学长，第一圈感觉他已经坚持不住了，但是最后还是和大队伍一起坚持跑下来了，意志力远胜于我。怪不得他能成为交大年度人物，还是专业第一。 让我引以为傲的意志力也被打到了，甲亢一年多来，自己真的是越来越差。 下午和协会的大家一起拍宣传照，协会里的人都很好。 今天一天都很充实，也很难过。","link":"/2020/12/05/%E6%97%A5%E8%AE%B0-%E8%AE%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%98%AF%E5%BE%88%E5%BC%80%E5%BF%83%E7%9A%84%E5%91%A8%E5%85%AD/"},{"title":"C++1X: quick sort using C++1X features","text":"近年来，C++ 不断发展，新的标准不断涌现，而我还停留在把 C++ 当成 具有面向对象特性的 C 来看待和使用。新的 C++ 标准给我们带来了很多特性，并且能够使得我们的代码变得更加简洁。 这篇文章是我第一次学习使用 C++ 11/14/17 特性时的笔记，希望使用 C++ 11/14/17 特性写一个泛型的 quick sort 函数。","link":"/2020/12/07/C-1X-quick-sort-using-C-1X-features/"},{"title":"Paper Reading: Cooperation and Security Isolation of Library OSes for Multi-Process Applications","text":"","link":"/2020/12/06/Paper-Reading-Cooperation-and-Security-Isolation-of-Library-OSes-for-Multi-Process-Applications/"},{"title":"Run unmodified c++ program under the support of graphene-sgx","text":"SGX 是 Intel 近几年来才有的硬件安全特性，可以将应用放在一段加密内存中保护起来。在 SGX 的保护下即使 VMM、Kernel 完全被攻击者挟持，也无法攻击其中的应用。 但是 SGX 有一套自己的编程规范，需要定义 edl 文件，并且需要比较细粒度的对应用进行切分，划分 Trust/Untrust，这对编程人员来说造成了一定的困难。而 Graphene-SGX 则是 Graphene 的作者和 Intel 的专家合作开发的 libOS，可以在不修改应用的情况下将其运行在 SGX 中。 本文主要是记录我在学习使用 Graphene-SGX 时，第一次成功运行 c++ 的 hello-world 程序的过程。 安装 GrapheneGraphene 是 oscarlab 在 libOS 上的工作研究。在 EuroSys’14 上，该实验室发表了 Graphene 的相关研究成果。在 Intel SGX 出现后，在 ATC’17 上该实验室又和 Intel 合作发表了 Graphene-SGX 的相关研究成果。目前 Graphene 已经在 github 上开源，repo 地址：https://github.com/oscarlab/graphene Graphene 的官方文档中对于如何使用介绍的内容比较少（也可能是我没读懂），我主要是通过学习其中的 example 摸索出如何使用这个 libOS。 根据文档的提示，首先下载 graphene ，可以通过 git clone https://github.com/oscarlab/graphene.git 的方式。 因为需要 graphene-sgx 的特性，因此 host 机器上必须安装 Intel-sgx-driver，以记 Intel-sgxsdk 文档在这一块的说明比较详细，有以下几点需要注意： 按照文档的说明，graphene-sgx 需要 Linux kernel 开启 FSGSBASE 特性，因此可能需要编译更新 kernel， 打 patch。 clone 下来的 graphene 有一个 submodule 引用了 graphene-sgx-driver , 因此需要运行 git submodule update --init -- Pal/src/host/Linux-SGX/sgx-driver/。 在文档 Quick Start 中的第 3 步中，注释提示，terminal 可能会要求我们输入 path to the Intel SGX driver code，这里其实就是输入 sgx.h 头文件的目录所在，可以在 Intel sgx driver 的安装目录找到 sgx.h，然后把目录复制过来就好。 1234cd $GRAPHENE_DIRmake SGX=1# the console will prompt you for the path to the Intel SGX driver code# (simply press ENTER if you use the in-kernel Intel SGX driver) 所有都编译成功后，运行 Quick Start 中的 test 也通过了，就说明安装成功了。 使用 Graphene-SGX接下来就可以自己学习写一个 manifest，来运行我们的 c++ program。 第一次使用，我运行的程序比较简单，是 c++ 版的 hello-world, 代码如下： 12345#include &lt;iostream&gt;int main() { std::cout &lt;&lt; &quot;Hello, test!&quot; &lt;&lt; std::endl;} 代码写好之后，我们就需要写一个 Makefile 文件，这里主要是需要参考 Examples/ 目录下的示例。 Makefile 编写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# Use one of these commands to build the manifest for Bash:## - make# - make DEBUG=1# - make SGX=1# - make SGX=1 DEBUG=1## Use `make clean` to remove Graphene-generated files.# Relative path to Graphene root and key for enclave signingGRAPHENEDIR ?= ../..SGX_SIGNER_KEY ?= $(GRAPHENEDIR)/Pal/src/host/Linux-SGX/signer/enclave-key.pemifeq ($(DEBUG),1)GRAPHENEDEBUG = inlineelseGRAPHENEDEBUG = noneendif.PHONY: allall: test.manifest | test pal_loaderifeq ($(SGX),1)all: test.tokenendifinclude ../../Scripts/Makefile.configs# Generating manifest rules for Bash dependenciesstest.manifest: manifest.template sed -e 's|$$(GRAPHENEDIR)|'&quot;$(GRAPHENEDIR)&quot;'|g' \\ -e 's|$$(GRAPHENEDEBUG)|'&quot;$(GRAPHENEDEBUG)&quot;'|g' \\ -e 's|$$(ARCH_LIBDIR)|'&quot;$(ARCH_LIBDIR)&quot;'|g' \\ $&lt; &gt; $@# Generating the SGX-specific manifest (*.manifest.sgx), the enclave signature,# and the token for enclave initialization.test.manifest.sgx: test.manifest $(GRAPHENEDIR)/Pal/src/host/Linux-SGX/signer/pal-sgx-sign \\ -exec test \\ -libpal $(GRAPHENEDIR)/Runtime/libpal-Linux-SGX.so \\ -key $(SGX_SIGNER_KEY) \\ -manifest test.manifest -output $@test.sig: test.manifest.sgxtest.token: test.sig $(GRAPHENEDIR)/Pal/src/host/Linux-SGX/signer/pal-sgx-get-token \\ -output test.token -sig test.sigtest: g++ test.cpp -o $@pal_loader: ln -s $(GRAPHENEDIR)/Runtime/pal_loader $@.PHONY: all.PHONY: cleanclean: $(RM) *.manifest *.manifest.sgx *.token *.sig test pal_loader.PHONY: distcleandistclean: clean 第 11 行 - 第 26 行基本上是 Examples 中的公共部分，这里主要是定义了一些变量，后面将会使用。 在 SGX enabled 时，需要生成的目标文件一共有：*.manifest, *.manifest.sgx, *.sig, *.token, *, pal_loader *.manifest: 该文件主要是定义了 graphene 创建隔离环境时需要挂载的文件、挂载的地方、环境变量等等。具体的将会在后一节内容详细介绍。 *.manifest.sgx: 该文件是在 *.manifest 的基础上对依赖的 trusted_files 进行了签名，以用于加载到 enclave 时进行完整性检查。 *.sig: *.token: *.pal_loader: Manifest 编写Manifest 中主要定义一些 Graphene 需要挂载的库、挂载的路径，环境变量，SGX 相关配置，SGX 信任的文件等等。 General 部分12345678910111213loader.argv0_override = &quot;$(ARGV0_OVERRIDE)&quot;# Read application arguments directly from the command line. Don't use this on production!loader.insecure__use_cmdline_argv = 1# Graphene environment, including the path of the library OS and the debug# option (inline/none).loader.preload = &quot;file:$(GRAPHENEDIR)/Runtime/libsysdb.so&quot;loader.debug_type = &quot;$(GRAPHENEDEBUG)&quot;# Environment variablesloader.env.LD_LIBRARY_PATH = &quot;/lib:$(ARCH_LIBDIR)::/usr/lib/x86_64-linux-gnu&quot;loader.env.PATH = &quot;/&quot; 第 1 行的 loader.argv0_override 是指在运行 ./pal_loader xxx 时，用 xxx 来代替 pal_loader，也就是运行这个 xxx 程序的意思。 第 11 行的 loader.env.LD_LIBRARY_PATH 指定了程序运行时需要的库加载路径，我猜想，程序运行时应该需要到这些路径上去搜索库。 Mount 部分12345678910111213141516171819202122# Mounted FSes. The following &quot;chroot&quot; FSes mount a part of the host FS into the# guest. Other parts of the host FS will not be available in the guest.# Default glibc files, mounted from the Runtime directory in GRAPHENEDIR.fs.mount.lib1.type = &quot;chroot&quot;fs.mount.lib1.path = &quot;/lib&quot;fs.mount.lib1.uri = &quot;file:$(GRAPHENEDIR)/Runtime&quot;# stdc++ files, mounted from /usr/lib/ARCHfs.mount.lib2.type = &quot;chroot&quot;fs.mount.lib2.path = &quot;/usr/lib/x86_64-linux-gnu&quot;fs.mount.lib2.uri = &quot;file:/usr/lib/x86_64-linux-gnu&quot;# Mount host-OS directory contanining libcrypt and NSS libraries.fs.mount.lib3.type = &quot;chroot&quot;fs.mount.lib3.path = &quot;$(ARCH_LIBDIR)&quot;fs.mount.lib3.uri = &quot;file:$(ARCH_LIBDIR)&quot;# Mount /binfs.mount.bin.type = &quot;chroot&quot;fs.mount.bin.path = &quot;/bin&quot;fs.mount.bin.uri = &quot;file:/bin&quot; 接下来就是挂载，可以看到，在这次使用中，我挂载了四个目录，之所以这样，是因为 hello-world 这个程序的依赖包含了不同路径的库。 要检查某个程序依赖哪些库，可以通过 ldd xxx 来查看，ldd xxx 的结果应该都需要挂载到 graphene 中。 manifest 中所有的 bash-like variable 都需要在 Makefile 中将其替换成字面量。这个也是 *.manifest 目标文件生成时所需要做的主要工作。可以看到，在这个 Makefile 中，主要是通过 sed -e 's|xx|'xx'|g' 来完成的。 SGX 部分1234567891011121314151617181920212223242526# Set the virtual memory size of the SGX enclave. For SGX v1, the enclave# size must be specified during signing. If the program needs more virtual# memory than the enclave size, Graphene will not be able to allocate it.sgx.enclave_size = &quot;256M&quot;# Set the maximum number of enclave threads. For SGX v1, the number of enclave# TCSes must be specified during signing, so the application cannot use more# threads than the number of TCSes. Note that Graphene also creates an internal# thread for handling inter-process communication (IPC), and potentially another# thread for asynchronous events. Therefore, the actual number of threads that# the application can create is (sgx.thread_num - 2).sgx.thread_num = 4# SGX trusted libraries# Glibc librariessgx.trusted_files.ld = &quot;file:$(GRAPHENEDIR)/Runtime/ld-linux-x86-64.so.2&quot;sgx.trusted_files.libc = &quot;file:$(GRAPHENEDIR)/Runtime/libc.so.6&quot;sgx.trusted_files.libm = &quot;file:$(GRAPHENEDIR)/Runtime/libm.so.6&quot;sgx.trusted_files.libdl = &quot;file:$(GRAPHENEDIR)/Runtime/libdl.so.2&quot;sgx.trusted_files.librt = &quot;file:$(GRAPHENEDIR)/Runtime/librt.so.1&quot;sgx.trusted_files.libutil = &quot;file:$(GRAPHENEDIR)/Runtime/libutil.so.1&quot;sgx.trusted_files.libpthread = &quot;file:$(GRAPHENEDIR)/Runtime/libpthread.so.0&quot;# stdc++ librariessgx.trusted_files.libstdcpp = &quot;file:/usr/lib/x86_64-linux-gnu/libstdc++.so.6&quot;sgx.trusted_files.libgcc_s = &quot;file:/lib/x86_64-linux-gnu/libgcc_s.so.1&quot; 最后，sgx 部分主要需要配置 enclave 的相关参数，这和 SGX 编程模型中的 xml 配置文件的配置基本一致。 sgx.trusted_files.[identifier] 是在程序运行时需要加载的库，可以通过 ldd 来查看，应该是每一个依赖都需要列举在此处。但是由于我是第一次使用，所以也只能凭感觉，如果有错误，希望大家能指出！ 编译运行编写好之后，就可以通过简单的命令直接运行我们的 hello-world 程序。 12SGX=1 makeSGX=1 ./pal_loader test 如果一些顺利，将会输出 Hello, test! 哈哈哈，这是很简单的一个program，但是成功输出的时候，真的很开心！ 参考 Graphene 官方文档 https://graphene.readthedocs.io/en/latest/quickstart.html GNU Make 文档 https://www.gnu.org/software/make/manual/make.html Intel SGX 文档 https://download.01.org/intel-sgx/linux-1.7/docs/Intel_SGX_SDK_Developer_Reference_Linux_1.7_Open_Source.pdf","link":"/2020/12/14/Run-unmodified-c-program-under-the-support-of-graphene-sgx/"}],"tags":[{"name":"Linux kernel","slug":"Linux-kernel","link":"/tags/Linux-kernel/"},{"name":"Qemu","slug":"Qemu","link":"/tags/Qemu/"},{"name":"syscall","slug":"syscall","link":"/tags/syscall/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"C++11&#x2F;14&#x2F;17","slug":"C-11-14-17","link":"/tags/C-11-14-17/"},{"name":"Graphene","slug":"Graphene","link":"/tags/Graphene/"},{"name":"libos","slug":"libos","link":"/tags/libos/"},{"name":"EuroSys","slug":"EuroSys","link":"/tags/EuroSys/"},{"name":"SGX","slug":"SGX","link":"/tags/SGX/"},{"name":"Graphehe-sgx","slug":"Graphehe-sgx","link":"/tags/Graphehe-sgx/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Note","slug":"Linux/Note","link":"/categories/Linux/Note/"},{"name":"Paper Reading","slug":"Paper-Reading","link":"/categories/Paper-Reading/"},{"name":"日记","slug":"日记","link":"/categories/%E6%97%A5%E8%AE%B0/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Programming Language","slug":"C/Programming-Language","link":"/categories/C/Programming-Language/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"SGX","slug":"Note/SGX","link":"/categories/Note/SGX/"},{"name":"Security","slug":"Note/SGX/Security","link":"/categories/Note/SGX/Security/"}]}