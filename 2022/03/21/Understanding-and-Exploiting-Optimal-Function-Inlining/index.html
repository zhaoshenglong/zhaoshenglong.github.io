<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta charset="utf-8"><meta lang="zh"><title>Understanding and Exploiting Optimal Function Inlining - Dragon&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="臭豆腐的 blog"><meta name="msapplication-TileImage" content="/site-img/wechat.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="臭豆腐的 blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="本篇文章是 ASPLOS’2022 的 Best Paper 之一，论文逻辑非常清晰，读起来非常轻松，个人认为是一篇非常好的论文示范。本篇文章主要的工作是系统研究了optimal inline*，并提出了一种达到 *optimal inline 的方式，在此基础上设计实现了一个 autotunner，进行内联优化。本文的测试非常详细，从 micro benchmark 到 real world a"><meta property="og:type" content="blog"><meta property="og:title" content="Understanding and Exploiting Optimal Function Inlining"><meta property="og:url" content="https://zhaoshenglong.github.io/2022/03/21/Understanding-and-Exploiting-Optimal-Function-Inlining/"><meta property="og:site_name" content="Dragon&#039;s blog"><meta property="og:description" content="本篇文章是 ASPLOS’2022 的 Best Paper 之一，论文逻辑非常清晰，读起来非常轻松，个人认为是一篇非常好的论文示范。本篇文章主要的工作是系统研究了optimal inline*，并提出了一种达到 *optimal inline 的方式，在此基础上设计实现了一个 autotunner，进行内联优化。本文的测试非常详细，从 micro benchmark 到 real world a"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zhaoshenglong.github.io/covers/default-cover.jpg"><meta property="article:published_time" content="2022-03-21T15:21:47.000Z"><meta property="article:modified_time" content="2022-03-22T04:02:03.750Z"><meta property="article:author" content="Zhao Shenglong"><meta property="article:tag" content="ASPLOS"><meta property="article:tag" content="Best Paper"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/covers/default-cover.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zhaoshenglong.github.io/2022/03/21/Understanding-and-Exploiting-Optimal-Function-Inlining/"},"headline":"Dragon's blog","image":["https://zhaoshenglong.github.io/covers/default-cover.jpg"],"datePublished":"2022-03-21T15:21:47.000Z","dateModified":"2022-03-22T04:02:03.750Z","author":{"@type":"Person","name":"Zhao Shenglong"},"description":"本篇文章是 ASPLOS’2022 的 Best Paper 之一，论文逻辑非常清晰，读起来非常轻松，个人认为是一篇非常好的论文示范。本篇文章主要的工作是系统研究了optimal inline*，并提出了一种达到 *optimal inline 的方式，在此基础上设计实现了一个 autotunner，进行内联优化。本文的测试非常详细，从 micro benchmark 到 real world a"}</script><link rel="canonical" href="https://zhaoshenglong.github.io/2022/03/21/Understanding-and-Exploiting-Optimal-Function-Inlining/"><link rel="icon" href="/site-img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/site-img/logo.svg" alt="Dragon&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Follow me" href="https://github.com/zhaoshenglong"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/covers/default-cover.jpg" alt="Understanding and Exploiting Optimal Function Inlining"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-21T15:21:47.000Z" title="2022-03-21T15:21:47.000Z">2022-03-21</time>发表</span><span class="level-item"><time dateTime="2022-03-22T04:02:03.750Z" title="2022-03-22T04:02:03.750Z">2022-03-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Paper-Reading/">Paper Reading</a></span><span class="level-item">17 分钟读完 (大约2553个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Understanding and Exploiting Optimal Function Inlining</h1><div class="content"><p>本篇文章是 <strong>ASPLOS’2022</strong> 的 <strong>Best Paper</strong> 之一，论文逻辑非常清晰，读起来非常轻松，个人认为是一篇非常好的论文示范。本篇文章主要的工作是系统研究了<em>optimal inline*，并提出了一种达到 *optimal inline</em> 的方式，在此基础上设计实现了一个 autotunner，进行内联优化。本文的测试非常详细，从 micro benchmark 到 real world applications 都有测试，并且测试结果都比较有指导意义。</p>
<a id="more"></a>

<p><img src="image-20220321233039096.png" alt="image-20220321233039096"></p>
<p>本文的作者如上图所示，主要是来自于 ETH 的研究者。首先声明，我对 inline optimization 并不了解，笔记中可能会有错误，不过这篇论文逻辑非常清晰，即使是我这样的小白，读来能够理解。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>我们都知道 inline 可以给程序带来很多好处，比如减小函数调用的开销（参数传递，栈帧维护等），此外编译器可以对 inline 后的程序进行优化，诸如 dead code 都可以被优化掉，可能会带来性能上的提升或者减小代码的大小。当然，inline 后的程序也有可能会变大，比如函数 C 被 A 和 B 都调用了，inline 后就会有两份 C，在没有优化的情况下自然就变大了。</p>
<p>作者在 introduction 部分用一张图来表示 inline 能为我们带来的好处（只看本文的图表也能理解本文表达的意思和思想，这也是逻辑清楚的一个体现）</p>
<p><img src="image-20220321234634686.png" alt="image-20220321234634686"></p>
<p>要想利用好 inline 带来的好处，我们需要决定哪里该使用 inline，哪里不开使用。做这种决策不是一件简单的事情，从 2000 年开始，就有学者们在研究 inline 的策略，提出了一些启发式的算法。这些启发式的算法很多也应用在了成熟的编译器上，比如 llvm 和 gcc。</p>
<p>但是一直以来，没有学者研究过 optimal inline 策略，当然这主要是由于 optimal inline 策略是一个 NPC 问题（NP-Complete Problem），没有多项式时间的解决方案。</p>
<p>给定一个程序，要想找到一个 optimal inline 策略，需要遍历该程序的所有函数调用在 inline和 no inline 之间组合的结果，解空间是2^n^</p>
<h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><ul>
<li>既然 optimal inline 策略是个 NPC 问题，对于它的研究是否还有价值和意义？<ul>
<li>optimal inline 策略在实际应用中是否能够应用？</li>
<li>现有的这些启发式 inline 策略和 optimal inline 策略的差距如何？<br>（这个问题是我，并不是作者在文章中提出来的，但是我认为文章解决的问题就是这样的问题）</li>
</ul>
</li>
</ul>
<h2 id="Formulate-the-inlineing-search-space"><a href="#Formulate-the-inlineing-search-space" class="headerlink" title="Formulate the inlineing search space"></a>Formulate the inlineing search space</h2><h3 id="Call-Graph"><a href="#Call-Graph" class="headerlink" title="Call Graph"></a>Call Graph</h3><p>学过编译的应该都知道 Call Graph 是什么，没学过的也很容易就能理解什么是 Call Graph。给定一个程序 P，假设 P 中有四个函数，分别为 A、B、C、D，假设 A 调用了 B，B 调用了 C，C 调用了 D。那么 P 的 Call Graph 就如下图所示</p>
<p><img src="call-graph.png" alt="call-graph"></p>
<h3 id="Naive-Search-Space"><a href="#Naive-Search-Space" class="headerlink" title="Naive Search Space"></a>Naive Search Space</h3><p>给定一个程序 P 和 P 的 call graph G，如果 G 有 $|E_G|$ 条边，那么所有 inline 的可能性，也就是搜索空间有 $2^{|E_G|}$ </p>
<p>naive 的方法在程序调用链比较小的时候还能奏效，但是程序的函数调用链一旦增加到50以上，几乎就是无法解决的。下图展示的是使用 naive 方法搜索 SPEC2017 的 inline 解空间，可以看到只有 camm4、lbm、mfc三个benchmark 是可以完整的搜素所有的解空间的。</p>
<p><img src="image-20220322084139519.png" alt="image-20220322084139519"></p>
<p>显然，直接无脑使用 naive 的方法是不可取的，我们能不能尽可能减小 inline 的搜索空间，来让更多的程序可以使用 optimal inline 的策略呢？</p>
<p>考虑下面这张图，虽然图中又条边，但是解空间实际上只有 $2^2 + 2^1 = 6$，因为左边和右边是独立的两个连通图，他们可以独立的进行 inline 优化，并不会互相影响优化效果。</p>
<p><img src="image-20220322085756505.png" alt="image-20220322085756505"></p>
<p>这个发现引出了本文的核心思想，对于独立的连通图，他们的优化彼此互不影响，作者们正是基于这个思想，大大减小了 optimal inline 的 search space</p>
<h3 id="Recursively-Partitioned-Search-Space"><a href="#Recursively-Partitioned-Search-Space" class="headerlink" title="Recursively Partitioned Search Space"></a>Recursively Partitioned Search Space</h3><p>我们以一个图来解释什么是 Recursively Partitioned Search Space</p>
<p><img src="image-20220322090617392.png" alt="image-20220322090617392"></p>
<p>上图（a）的是一个程序的 call graph，对于 $k\rightarrow L$ ，如果我们选择 inline 那么就会变成 图（c）的情形，搜索空间就是 $2^4$；如果我们不 inline，那么就会变成图（b）的情况。注意，$K\rightarrow L$ 不 inline 的效果在 inline 搜索时和分成两个连通图是一样的，显然，$F\rightarrow G \rightarrow K$ 和 $L\rightarrow H \rightarrow I$ 之间的优化彼此独立。那么在情况（b）下，要找到 optimal inline 只需要找到 $F \rightarrow G \rightarrow K$  的最优解和 $L \rightarrow H \rightarrow I$ 的最优解，就是情况（b）的最优解。因此对于情况（b）的搜索空间就是 $2^2 + 2^2 + 1$，其中  $2^2$ 每个子连通图的搜索空间，而 $+1$ 是整个程序在情况（b）下的解。</p>
<p>因此，图 (a) 所示的程序可以分成 图（b）和图（c）的情况，解空间的个数也就是 $2^4 + 2^2 + 2^2 + 1 = 25$，而如果使用 naive 的方法，解空间的个数是 $2^5 = 32$</p>
<p>上面的这种 partition 方法可以递归的在子树上进行，因此能大大缩减 inline 解空间的数量。</p>
<h3 id="Analyze-Optimal-Inlining-on-SPEC2017"><a href="#Analyze-Optimal-Inlining-on-SPEC2017" class="headerlink" title="Analyze Optimal Inlining on SPEC2017"></a>Analyze Optimal Inlining on SPEC2017</h3><p>这种方法能否在实际中进行应用呢？作者们在 SPEC2017 上进行了 optimal inline 的实验，并从实验结果发现了一些规律（这将会在下一节介绍）。</p>
<p><img src="image-20220322110115022.png" alt="image-20220322110115022"></p>
<p>上表展示的是在 SPEC2017 benchmark 上使用 naive search space 和 recursive partitioned search space 的解大小，显然 naive 的解空间无法用现用的资源计算出来，但是 recursive partitioned search space 就能够接受，最大也只有只有 $2^{20}$。</p>
<p>作者们还对比了 optimal inline 和 LLVM 启发式算法在 SPEC2017 上的优化效果，从下图可以看到，LLVM 的启发式算法在半数情况下能找到最优的 inline  策略，其他部分的优化效果比 optimal inline 略差，少部分 inline 后的目标文件大小增长比较大，最大的膨胀了 281%。</p>
<p><img src="image-20220322110737509.png" alt="image-20220322110737509"></p>
<p>此外，作者们还研究了 optimal inline 在 SPEC2017 的 call graph 上的 inline chain depth，结果如下图所示。</p>
<p><img src="image-20220322111228593.png" alt="image-20220322111228593"></p>
<p>可以看到，大部分的 inline chain 的深度只有 1，深度大于 4 的 inline chain 非常非常少。也就是说，在决定一个函数是否要 inline 的时候，大部分情况下只需要看这个函数 inline 和 no inline 哪一种情况优化效果好就可以了。</p>
<p>由此，本文作者又提出了一个基于局部 inline 的 autotuner，这个 autotuner 的工作流程非常简单：给定一个连通的 call graph，遍历这个 call graph 的每一条边，比较将这个边 inline 和 no inline 的编译优化效果，选择优化效果大。</p>
<p>上述算法只考虑深度为 1 的 inline chain，对于深度大于 1，比如深度为 2、3、4 的 inline chain，也是可以用同样的算法执行的，区别在于深度为 2 的 autotuner 的初始值是深度为 1 的 autotuner 结果。换一句话说，就是 autotuner 可以执行多个回合以期找到尽可能优的 inline 解。</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>本文的 evaluation 主要测试的是 autotuner，optimal inline 策略虽然在 benchmark 上可以执行，但是耗时比较久，并且在真实场景下应用也比较困难（search space 难以下降到可接受范围）。</p>
<p>在测试中，主要考虑一下三点：</p>
<ol>
<li>autotuner 和 LLVM 的启发式算法在 SPEC2017 上优化效果怎么样？</li>
<li>多回合的 autotuner 优化效果如何？</li>
<li>autotuner 能否在真实场景里应用？</li>
</ol>
<h3 id="Autotuner-V-S-LLVM’s-heuristic-inline-strategy"><a href="#Autotuner-V-S-LLVM’s-heuristic-inline-strategy" class="headerlink" title="Autotuner V.S. LLVM’s heuristic inline strategy"></a>Autotuner V.S. LLVM’s heuristic inline strategy</h3><p>autotuner 和 LLVM 启发式算法的测试结果如下图所示，可以看到，大部分 benchmark 上，autotuner 的优化效果优于 LLVM 启发式算法，也有部分 benchmark 上 autotuner 的优化效果不如 LLVM，当然，这个其实可以采取两种策略都进行测试，并选择较优的方案。</p>
<p><img src="image-20220322113759949.png" alt="image-20220322113759949"></p>
<p>autotuner 的初始化状态还可以设置为 LLVM 的优化结果，这样可以在 LLVM 的启发式算法之上进行 local tuning，当然测试结果也并不一定都好于其它初始状态（比如默认全部 no inline 的初始状态），比如下表的 benchmark 测试中，使用 clean state 就要优于使用 LLVM initialization。</p>
<p><img src="image-20220322114835965.png" alt="image-20220322114835965"></p>
<h3 id="Multi-round-autotuner"><a href="#Multi-round-autotuner" class="headerlink" title="Multi-round autotuner"></a>Multi-round autotuner</h3><p>作者们还对 multi-round autotuner 进行了测试，因为在 optimal inline 测试下，还是存在部分 inline chain 的深度大于 1 的。测试结果如下图所示</p>
<p><img src="image-20220322115624954.png" alt="image-20220322115624954"></p>
<p>可以看到，大部分程序在多个 round 之后优化效果都有提升。</p>
<h3 id="Real-world-applications"><a href="#Real-world-applications" class="headerlink" title="Real world applications"></a>Real world applications</h3><p>本文作者还在 LLVM 和 SQLite 上进行了 inline 优化测试。 在 LLVM 的测试上，一个 round 大约要运行 44 ~ 53 小时，不过优化效果也很明显，3 个回合后，二进制大小可以减少 15.21%。在 SQLite 上，每个 round 运行大概 90 分钟，优化后二进制大小是 LLVM 编译出来的二进制大小的 89.7%</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/ASPLOS/">ASPLOS</a><a class="link-muted mr-2" rel="tag" href="/tags/Best-Paper/">Best Paper</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5fc9e4be957af60014171a52&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/03/12/FuzzyLog-A-Partially-Ordered-Shared-Log/"><span class="level-item">FuzzyLog A Partially Ordered Shared Log</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zhaoshenglong/zhaoshenglong.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Introduction"><span class="level-left"><span class="level-item">1</span><span class="level-item">Introduction</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Motivation"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Motivation</span></span></a></li><li><a class="level is-mobile" href="#Problem-Statement"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Problem Statement</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Formulate-the-inlineing-search-space"><span class="level-left"><span class="level-item">2</span><span class="level-item">Formulate the inlineing search space</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Call-Graph"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Call Graph</span></span></a></li><li><a class="level is-mobile" href="#Naive-Search-Space"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Naive Search Space</span></span></a></li><li><a class="level is-mobile" href="#Recursively-Partitioned-Search-Space"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Recursively Partitioned Search Space</span></span></a></li><li><a class="level is-mobile" href="#Analyze-Optimal-Inlining-on-SPEC2017"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Analyze Optimal Inlining on SPEC2017</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Evaluation"><span class="level-left"><span class="level-item">3</span><span class="level-item">Evaluation</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Autotuner-V-S-LLVM’s-heuristic-inline-strategy"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Autotuner V.S. LLVM’s heuristic inline strategy</span></span></a></li><li><a class="level is-mobile" href="#Multi-round-autotuner"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Multi-round autotuner</span></span></a></li><li><a class="level is-mobile" href="#Real-world-applications"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Real world applications</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/03/21/Understanding-and-Exploiting-Optimal-Function-Inlining/"><img src="/covers/default-thumbnail.jpg" alt="Understanding and Exploiting Optimal Function Inlining"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-03-21T15:21:47.000Z">2022-03-21</time></p><p class="title"><a href="/2022/03/21/Understanding-and-Exploiting-Optimal-Function-Inlining/">Understanding and Exploiting Optimal Function Inlining</a></p><p class="categories"><a href="/categories/Paper-Reading/">Paper Reading</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/03/12/FuzzyLog-A-Partially-Ordered-Shared-Log/"><img src="/covers/default-thumbnail.jpg" alt="FuzzyLog A Partially Ordered Shared Log"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-03-12T15:14:15.000Z">2022-03-12</time></p><p class="title"><a href="/2022/03/12/FuzzyLog-A-Partially-Ordered-Shared-Log/">FuzzyLog A Partially Ordered Shared Log</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/10/09/NetVM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><img src="/covers/default-thumbnail.jpg" alt="NetVM 论文阅读"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-10-09T01:23:51.000Z">2021-10-09</time></p><p class="title"><a href="/2021/10/09/NetVM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">NetVM 论文阅读</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/31/Lab09-%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%95%99%E7%A8%8B/"><img src="/covers/Lab09-%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%95%99%E7%A8%8B-cover.jpg" alt="Lab09-个人网站教程"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-08-31T11:47:02.000Z">2021-08-31</time></p><p class="title"><a href="/2021/08/31/Lab09-%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%95%99%E7%A8%8B/">Lab09-个人网站教程</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/19/OSTEP-References-Summary/"><img src="/covers/default-thumbnail.jpg" alt="OSTEP References Summary"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-08-19T13:56:57.000Z">2021-08-19</time></p><p class="title"><a href="/2021/08/19/OSTEP-References-Summary/">OSTEP References Summary</a></p><p class="categories"><a href="/categories/Reading/">Reading</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/site-img/logo.svg" alt="Dragon&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Zhao Shenglong</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>